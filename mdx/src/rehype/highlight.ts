import { visit } from 'unist-util-visit'
import { match, P } from 'ts-pattern'
import type { Root, Node } from 'hast'

type InlineHighlight = {
  line: number,
  column: number,
  match: string,
  color?: string
}

type TextNode = { readonly type: 'text', readonly value: string }

type TokenNode = Node & {
  type: 'element',
  tagName: 'span',
  properties: Record<string, unknown>,
  children: readonly TextNode[]
}

type LineNode = Node & {
  type: 'element',
  tagName: 'span',
  properties: { className: string[] },
  children: TokenNode[]
}

type HighlightContainerNode = Node & {
  type: 'element',
  tagName: 'span',
  properties: { className: 'highlight', highlight: 'true', highlightColor: string | undefined },
  children: TokenNode[]
}

/**
 * This rehype plugin extracts highlights from the `annotation` property of a `pre` element (which is JSON string that contains a `highlights` array as provided by `mdx-annotations`)
 * and then splits up the tokens generated by `rehypeShiki` such that each highlight can be composed of multiple tokens.
 * Afterwards a new "highlight" token node is added with the previously mentioned tokens as children.
 *
 * This can be styled by hijacking the rendering of span elements and checking for the `highlight` property.
 */
export const rehypeHighlight = () => {
  return async (tree: Root) => {
    visit(tree, 'element', (node) => {
      // a "line node" is the node for a single line of code
      // it contains "token nodes" which each represent a single token
      const [maybeHighlights, maybeLineNodes] = match(node)
        .with(
          {
            tagName: 'pre',
            properties: {
              annotation: P.select('annotation', P.string)
            },
            children: [{ tagName: 'code', children: P.select('lineNodes') }]
          },
          ({ annotation, lineNodes }) => {
            let highlights: InlineHighlight[]
            try {
              // TODO: why isn't the type of annotation inferred correctly here?
              highlights = JSON.parse(annotation as string).highlights as InlineHighlight[]
            } catch (error) {
              throw new Error('annotations have to be valid JSON and must contain a `highlights` array')
            }
            // TODO: can't pass any further type guards to P.select for some reason, this seems to be a bit broken in ts-pattern, thus we have to type-cast here
            const elementLineNodes = lineNodes.filter(({ type }) => type === 'element') as unknown as LineNode[]

            return [highlights, elementLineNodes] as const
          }
        )
        .otherwise(() => [undefined, undefined])

      if (maybeHighlights === undefined || maybeLineNodes === undefined) return

      const highlights = maybeHighlights
      const lineNodes = maybeLineNodes

      const relevantLineNodes = lineNodes
        .map((line, lineNumber) => [
          highlights.some((highlight) => highlight.line - 1 === lineNumber),
          lineNumber,
          line
        ] as const)
        .filter(([isRelevant]) => isRelevant)
        .map(([, lineNumber, lineNode]) => [lineNumber, lineNode] as const)

      highlights.forEach((highlight) => {
        // we know that this will not be undefined because we previously filtered using that condition
        const [, lineNode] = relevantLineNodes.find(([lineNumber]) => highlight.line - 1 === lineNumber) as [number, LineNode]

        // columns is 1-based, convert to 0-based
        const start = highlight.column - 1
        const end = highlight.column - 1 + highlight.match.length - 1

        const tokens = lineNode.children

        let accumulatedTokenLength = 0

        for (let i = 0; i < tokens.length; i++) {
          const tokenLength = tokens[i].children[0].value.length
          const tokenText = tokens[i].children[0].value

          const tokenStart = accumulatedTokenLength
          const tokenEnd = tokenStart + tokenLength - 1

          // determine if token is start of highlight
          const isStartOfHighlight = start >= tokenStart && start <= tokenEnd

          // determine if token is end of highlight
          const isEndOfHighlight = end >= tokenStart && end <= tokenEnd

          // determine if token is in the middle of the highlight
          const isMiddleOfHighlight = start < tokenStart && end > tokenEnd

          // determine if token is part of the highlight
          const isPartOfHighlight = isStartOfHighlight || isMiddleOfHighlight || isEndOfHighlight

          if (isPartOfHighlight) {
            const shouldSplitStart = isStartOfHighlight && start > tokenStart
            const shouldSplitEnd = isEndOfHighlight && end < tokenEnd

            if (shouldSplitStart && shouldSplitEnd) {
              const notHighlightedStartPart = tokenText.slice(0, start - tokenStart)
              const highlightedPart = tokenText.slice(start - tokenStart, start - tokenStart + match.length)
              const notHighlightedEndPart = tokenText.slice(start - tokenStart + match.length, tokenLength)

              const notHighlightedStartToken = {
                type: 'element',
                tagName: 'span',
                properties: tokens[i].properties,
                children: [{ type: 'text', value: notHighlightedStartPart }]
              } as const
              const highlightedToken = {
                type: 'element',
                tagName: 'span',
                properties: { ...tokens[i].properties, highlight: true },
                children: [{ type: 'text', value: highlightedPart }]
              } as const
              const notHighlightedEndToken = {
                type: 'element',
                tagName: 'span',
                properties: tokens[i].properties,
                children: [{ type: 'text', value: notHighlightedEndPart }]
              } as const

              tokens[i] = notHighlightedStartToken
              tokens.splice(i + 1, 0, highlightedToken)
              tokens.splice(i + 2, 0, notHighlightedEndToken)

              i += 2
              accumulatedTokenLength += tokenLength

              continue
            }

            // start of highlight is in the middle of the current token -> split token into two tokens
            if (shouldSplitStart) {
              const notHighlightedPart = tokenText.slice(0, start - tokenStart)
              const highlightedPart = tokenText.slice(start - tokenStart)

              if (!highlight.match.startsWith(highlightedPart)) {
                throw new Error(`sanity check failed: "${highlight.match}" does not start with "${highlightedPart}"`)
              }

              const notHighlightedToken = {
                type: 'element',
                tagName: 'span',
                properties: tokens[i].properties,
                children: [{ type: 'text', value: notHighlightedPart }]
              } as const
              const highlightedToken = {
                type: 'element',
                tagName: 'span',
                properties: { ...tokens[i].properties, highlight: true },
                children: [{ type: 'text', value: highlightedPart }]
              } as const

              tokens[i] = notHighlightedToken
              tokens.splice(i + 1, 0, highlightedToken)
              i++
              accumulatedTokenLength += tokenLength

              continue
            }

            // end of highlight is in the middle of the current token -> split token into two tokens
            if (shouldSplitEnd) {
              const highlightedPart = tokenText.slice(0, end - tokenStart)
              const notHighlightedPart = tokenText.slice(end - tokenStart)

              if (!highlight.match.endsWith(highlightedPart)) {
                throw new Error(`match sanity check failed: "${highlight.match}" does not end with "${highlightedPart}"`)
              }

              const highlightedToken = {
                type: 'element',
                tagName: 'span',
                properties: { ...tokens[i].properties, highlight: true },
                children: [{ type: 'text', value: highlightedPart }]
              } as const
              const notHighlightedToken = {
                type: 'element',
                tagName: 'span',
                properties: tokens[i].properties,
                children: [{ type: 'text', value: notHighlightedPart }]
              } as const

              tokens[i] = highlightedToken
              tokens.splice(i + 1, 0, notHighlightedToken)
              i++
              accumulatedTokenLength += tokenLength

              continue
            }

            // the highlight will at least go until the end of the current token
            // thus we replace the current token with a new one that contains the highlight
            // we also need to ensure that the text of the token matches the `match` string of the highlight
            // this is just a sanity check to make sure that the highlight is correct and that updates to the
            // code block don't break highlights
            if (!highlight.match.includes(tokenText)) {
              throw new Error('match sanity check failed: highlight does not include token text')
            }

            tokens[i].properties.highlight = true
            accumulatedTokenLength += tokenLength

            continue
          }

          accumulatedTokenLength += tokenLength
        }

        // replace the tokens that are part of the highlight with a single container node containing the tokens
        // for this we first need to search for the first occurance of a token that is part of the highlight
        // and then use Array#splice to replace `highlightTokenNodes.length` many tokens with the containing node
        // which we call `highlightContainerNode`
        let startIndex: number | undefined
        const highlightTokenNodes = []

        for (let i = 0; i < tokens.length; i++) {
          if (tokens[i].properties.highlight) {
            if (startIndex === undefined) {
              startIndex = i
            }
            tokens[i].properties.highlight = undefined
            highlightTokenNodes.push(tokens[i])
          }
        }

        const highlightContainerNode: HighlightContainerNode = {
          type: 'element',
          tagName: 'span',
          properties: { className: 'highlight', highlight: 'true', highlightColor: highlight.color },
          children: highlightTokenNodes
        } as const

        if (startIndex === undefined) {
          throw new Error('Something went wrong, startIndex is undefined, this should not happen')
        }

        (tokens as Array<TokenNode | HighlightContainerNode>).splice(startIndex, highlightTokenNodes.length, highlightContainerNode)
      })
    })
  }
}
